# webpack打包原理流程解析

## 创建一个简单的webpack的Demo

首先创建一个文件夹-webpackTest

使用npm init命令，对文件夹进行初始化

![](../../assets/webpack/1.png)

安装webpack

`npm i webpack`

创建webpack.config.js文件，定义入口文件和出口文件

```javascript
const path = require('path')
module.exports = {
    mode: "production",
    entry: {
        main:'./src/main.js'
    },
    output: {
        path: path.resolve(__dirname,'dist'),
        filename: "chunk.js"
    }
}
```

在package.json中添加webpack打包命令即可通过命令进行打包

```
"scripts": {
  "test": "echo \"Error: no test specified\" && exit 1",
  "build": "webpack"
},
```

## AST-抽象的语法树（对象）

将代码解析成一个对象

1. 解析入口文件 获取AST（配置）手写解析器 babel/parser
2. 找到所有的依赖模块
3. 将AST语法树转为浏览器可以执行的代码
4. 递归解析所有的依赖项 生成依赖关系图
5. 重写require函数 输出bundle

作用：

- 依赖分析
- 代码转化
- 优化和分析

### 解析入口文件，创建一个AST对象

通过使用babel/parser，将JavaScript代码转换为AST

```javascript
const  fs = require('fs');
const parser = require('@babel/parser')
const options = require('./webpack.config')
const path = require("path");

const Parser = {
    // 这里的path是指需要将入口文件的路径传过来
    getAst: path=>{
        // 读取入口文件,将其转换为utf-8
        const context = fs.readFileSync(path,'utf-8')
        return parser.parse(context,{
            sourceType:'module'
        })
    }
}

class Compiler {
    constructor(options) {
        const { entry , output } = options
        // 入口文件
        this.entry = entry
        // 出口文件
        this.output = output
    }
    run(){
        // 获取到转换后的AST对象
        const ast = Parser.getAst(this.entry)
        console.log(ast)
    }
    generate(){}
}
// 创建一个Compiler实例
new Compiler(options).run();

```

### 找到所有的依赖模块

使用babel中的@babel/traverse工具获取入口文件的所有依赖

- 遍历AST的结点，
- 访问和修改结点，通过traverse提供的各种访问可以访问每个结点的属性等，并且对其进行修改
- 条件跳过和终止遍历的操作
- 插件开发（针对特定的结点）

```javascript
const dependence = Parser.getDependence(ast,this.entry)
// 在parser中构建获取入口文件依赖的方法
// 获取入口文件的依赖的方法
getDependence: (ast,fileName)=>{
    // 注册处理函数对ast进行处理
    const dependence ={}
    // node是调用traverse中的方法时的自带的参数。第二个参数是traverse的配置对象
    // ImportDeclaration和CallExpression都是traverse内置的方法
    // import 语句结点
    traverse(ast,{
        ImportDeclaration({node}) {
            // 获取到整个依赖树的根节点-根据传进来的入口文件
            const dirname = path.dirname(fileName)
            // 生成依赖模块的路径
            const filePath = './'+path.join(dirname,node.source.value)
            dependence[node.source.value] = filePath
        },
        // 当遇到函数调用表达式的情况的时候
        // 获取到node结点的信息
        CallExpression({node}){
            // 如果函数调用名是require的话
            if (node.callee.name ==='require') {
                const moduleName = node.arguments[0].value
                // 将模块名添加到依赖列表中
                dependence[moduleName] = moduleName
            }
        }
    })
    return dependence
}
```

### 将AST语法树转为浏览器可以执行的代码

@babel/core和@babel/preset-env工具包

- @babel/core：转换代码，将源代码转换为目标代码
- @babel/preset-env：设置转换的规则

@babel/core

1. 转换代码
2. 编译代码
3. 配置选项
4. api的接口

@babel/preset-env

1. 根据目标环境自动确认转换规则
2. 按需加载转换的插件--只会加载必要的转换插件
3. 智能处理浏览器的兼容性

在Parser中定义getCode的方法将ast转换为浏览器可识别的code

```javascript
const { transformFromAst } = require('@babel/core')
// 进行代码转换的方法--将ast转换为浏览器能执行的code
getCode:(ast)=>{
    const {code} = transformFromAst(ast,null,{
        presets:['@babel/preset-env'] // 通过预设的模块来进行转换
    })
    return code
}
```





























